#!/bin/sh

set -e

SHELL="$(readlink /proc/$$/exe)"
if [ "$(basename "$SHELL")" = busybox ]
then
  SHELL=sh
fi
IMAGE_TAG="${IMAGE_TAG:-development-jvm}"
IMAGE_NAME="stackgres/operator:$IMAGE_TAG"
KUBERNETES_VERSION="${KUBERNETES_VERSION:-1.12.10}"
E2E_ENV="${E2E_ENV:-kind}"
SPEC_PATH="$(dirname "$0")/spec"
TARGET_PATH="$(dirname "$0")/target"
BUILD_OPERATOR="${BUILD_OPERATOR:-true}"
WAIT_OPERATOR="${WAIT_OPERATOR:-true}"
E2E_TIMEOUT="${E2E_TIMEOUT:-180}"
TRAP_ENABLED="${TRAP_ENABLED:-false}"
SKIP_K8S_SETUP="${SKIP_K8S_SETUP:-false}"
OPERATOR_PULL_POLICY="${OPERATOR_PULL_POLICY:-Never}"

if [ -z "$STACKGRES_PATH" ]
then
  STACKGRES_PATH="$(dirname "$0")/.."
fi
OPERATOR_CHART_PATH="${OPERATOR_CHART_PATH:-"$STACKGRES_PATH/install/helm/stackgres-operator/"}"
CLUSTER_CHART_PATH="${CLUSTER_CHART_PATH:-"$STACKGRES_PATH/install/helm/stackgres-cluster/"}"

export SHELL IMAGE_TAG IMAGE_NAME KUBERNETES_VERSION CLUSTER_CHART_PATH E2E_ENV TARGET_PATH E2E_TIMEOUT

if ! command -v local > /dev/null 2>&1
then
  >&2 echo "You are probably using an AT&T Korn Shell or any other shell that does not support local variables in POSIX functions."
  exit 1
fi

for util in $(find "$(dirname "$0")/utils" -type f)
do
  . "$util"
done

operator_pull_policy() {
  echo $OPERATOR_PULL_POLICY
}

. "$(dirname "$0")/envs/$E2E_ENV"

trap_kill() {
  echo "$1" >> "$TRAP_FILE"
}

trap_callback() {
  if [ -s "$TRAP_FILE" ]
  then
    sleep 1 || true # Let the tails write to output remaining logs.
    kill $(cat "$TRAP_FILE") >/dev/null 2>&1 || true
  fi
}

if [ -z "$TRAP_FILE" ]
then
  mkdir -p "$TARGET_PATH"
  TRAP_FILE="$TARGET_PATH/trap-kill-$(shuf -i 0-65535 -n 1)"
  export TRAP_FILE
  trap 'trap_callback' EXIT
  trap 'exit $?' HUP INT QUIT PIPE TERM
fi

trap_kill_all() {
  local file
  for file in $(find "$TARGET_PATH" -name 'trap-kill-*')
  do
    kill $(cat "$file") >/dev/null 2>&1 || true
  done
}

setup_k8s() {
  mkdir -p "$TARGET_PATH/logs"

  if [ "$SKIP_K8S_SETUP" = true ]
  then
    return
  fi

  if [ "$REUSE_K8S" != true ]
  then
    reset_k8s
  else
    reuse_k8s
  fi

  setup_helm

  setup_default_limits 0.1 0.1 16Mi 16Mi

  helm dependency update "$OPERATOR_CHART_PATH"
  helm dependency update "$CLUSTER_CHART_PATH"

  if [ "$BUILD_OPERATOR" = true ] \
    && (
      ! helm list | grep -q "^stackgres-operator\s" \
      || [ "$REUSE_OPERATOR" != true ]
    )
  then
    (
    cd "$STACKGRES_PATH/src"
    ./mvnw -q clean package -P build-image-jvm
    )
  fi

  if ! helm list | grep -q "^stackgres-operator\s" \
    || ! kubectl get namespaces stackgres -o name \
      | grep -q "^namespace/stackgres$" \
    || (! kubectl get deployments.apps -n stackgres -o name \
      | grep -q "^deployment.apps/stackgres-operator$" \
      && [ "$USE_EXTERNAL_OPERATOR" != true ])\
    || [ "$REUSE_OPERATOR" != true ]
  then
    if [ "$FORCE_IMAGE_PULL" = "true" ] \
      || docker image inspect $IMAGE_NAME >/dev/null 2>&1
    then
      docker pull $IMAGE_NAME
    fi
    load_operator_k8s
    helm_cleanup
    k8s_cleanup

    helm install --name stackgres-operator --namespace stackgres "$OPERATOR_CHART_PATH" \
      --set-string image.tag="$IMAGE_TAG" --set-string "image.pullPolicy=$(operator_pull_policy)"
    if [ "$DEBUG_OPERATOR" = true ]
    then
      wait_pods_running stackgres
      kubectl set env -n stackgres deployment/stackgres-operator \
        DEBUG_OPERATOR="$DEBUG_OPERATOR" DEBUG_OPERATOR_SUSPEND="$DEBUG_OPERATOR_SUSPEND"
      kubectl delete pod -n stackgres "$(kubectl get pod -n stackgres -o name|cut -d / -f 2|tail -n 1)"
    fi
  else
    helm_cleanup_but_operator
    k8s_cleanup_but_operator
  fi

  if [ "$WAIT_OPERATOR" = true ]
  then
    wait_pods_running stackgres
  fi
  wait_pods_running
}

if [ "$(basename "$0")" = "e2e" -a ! -z "$1" ]
then
  "$@"
fi
