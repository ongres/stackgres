#!/bin/sh

e2e_test_install() {
  OPERATOR_NAMESPACE="stackgres"
  DEFAULT_PGCONFIG="defaultpgconfig"
  PGCBOUNCER="pgbouncer"
  PGCONFIG="postgresconf"
  
  kubectl create namespace "$CLUSTER_NAMESPACE"
  deploy_curl_pod "$CLUSTER_NAMESPACE"
  wait_pods_running "$CLUSTER_NAMESPACE" 1
}

e2e_test_uninstall() {
  k8s_cleanup_namespace "$CLUSTER_NAMESPACE"

  kubectl delete sgclusters.stackgres.io -n $OPERATOR_NAMESPACE $CLUSTER_NAME
}

e2e_test() {
  run_test "creating an empty pgconfig should be filled with default configurations" create_empty_pg_config 
  run_test "creating an empty pgbouncer should be filled with default configurations" create_empty_pg_bouncer
  run_test "if default configuration are already created it should create the cluster" create_empty_cluster_with_default_pgbouncer
  run_test "if the sidecars are specifically set to be empty the operator should not add any sidecar" create_empty_cluster_with_no_sidecars
  run_test "creating an empty cluster should trigger the creation of all default configurations" create_empty_cluster
  run_test "creating en empty cluster in the operator should no fail" create_empty_cluster_on_operator_namespace
}

create_empty_pg_config() {

  cat << EOF | kubectl apply -f -
  apiVersion: stackgres.io/v1beta1
  kind: SGPostgresConfig
  metadata:
    name: $PGCONFIG
    namespace: $CLUSTER_NAMESPACE
  spec:
    pgVersion: "11"
EOF

  local CREATED_FIELDS=$(kubectl get sgpgconfigs.stackgres.io -n $CLUSTER_NAMESPACE $PGCONFIG -o json | run_jq '.spec["postgresql.conf"] | length')
  local DEFAULT_FIELDS=$(get_default_pgconfig -o json | run_jq '.spec["postgresql.conf"] | length')

  if [ $CREATED_FIELDS = $DEFAULT_FIELDS ]
  then
    echo "Success. Defaults fields created"
  else
    echo "Fail. Default fields not created"
    return 1
  fi

  local DEFAULT_ANNOTATION=$(kubectl get sgpgconfigs.stackgres.io -n $CLUSTER_NAMESPACE $PGCONFIG -o json | run_jq '.metadata.annotations["stackgres.io/operatorVersion"]')

  if [ -z "$DEFAULT_ANNOTATION" ] || [ "$DEFAULT_ANNOTATION" = "null" ]
  then
    echo "Fail. Default annotations not created"
    return 1
  else
    echo "Success. Defaults annotations created"
  fi

}

create_empty_pg_bouncer() {

  cat << EOF | kubectl apply -f -
  apiVersion: stackgres.io/v1beta1
  kind: SGPoolingConfig
  metadata:
    name: $PGCBOUNCER
    namespace: $CLUSTER_NAMESPACE
  spec:
    pgbouncer.ini:
      unsignificant: true
EOF

  local CREATED_FIELDS=$(kubectl get sgpoolconfigs.stackgres.io -n $CLUSTER_NAMESPACE $PGCBOUNCER -o json | run_jq '.spec["pgbouncer.ini"] | length')
  local DEFAULT_FIELDS=$(get_default_conn_pool -o json | run_jq '.spec["pgbouncer.ini"] | length')

  if [ $CREATED_FIELDS = $((DEFAULT_FIELDS + 1)) ]
  then
    echo "Success. Defaults fields created"
  else
    echo "Fail. Default fields not created"
    return 1
  fi

  local DEFAULT_ANNOTATION=$(kubectl get sgpoolconfigs.stackgres.io -n $CLUSTER_NAMESPACE $PGCBOUNCER -o json | run_jq '.metadata.annotations["stackgres.io/operatorVersion"]')

  if [ -z "$DEFAULT_ANNOTATION" ] || [ "$DEFAULT_ANNOTATION" = "null" ]
  then
    echo "Fail. Default annotations not created"
    return 1
  else
    echo "Success. Defaults annotations created"
  fi
}

create_empty_pg_backup_config() {

  cat << EOF | kubectl apply -f -
  apiVersion: stackgres.io/v1beta1
  kind: SGBackupConfig
  metadata:
    name: $BACKUP_CONFIG
    namespace: $CLUSTER_NAMESPACE
  spec:
    compressionMethod=lz4
EOF

  local CREATED_FIELDS=$(kubectl get sgbackupconfigs.stackgres.io -n $CLUSTER_NAMESPACE $BACKUP_CONFIG -o json | run_jq '.spec | length')
  local DEFAULT_FIELDS=$(get_default_backupconf | run_jq '.spec | length')

  if [ $CREATED_FIELDS = $((DEFAULT_FIELDS + 1)) ]
  then
    echo "Success. Defaults fields created"
  else
    echo "Fail. Default fields not created"
    return 1
  fi

  local DEFAULT_ANNOTATION=$(kubectl get sgbackupconfigs.stackgres.io -n $CLUSTER_NAMESPACE $BACKUP_CONFIG -o json | run_jq '.metadata.annotations["stackgres.io/operatorVersion"]')

  if [ -z "$DEFAULT_ANNOTATION" ] || [ "$DEFAULT_ANNOTATION" = "null" ]
  then
    echo "Fail. Default annotations not created"
    return 1
  else
    echo "Success. Defaults annotations created"
  fi
}

create_empty_cluster_with_default_pgbouncer() {

  cat <<EOF | kubectl apply -f -
  apiVersion: stackgres.io/v1beta1
  kind: SGCluster
  metadata:
    name: $CLUSTER_NAME-pgbouncer
    namespace: $CLUSTER_NAMESPACE
  spec:
    instances: 1
    postgresVersion: 'latest'
    pods:
      persistentVolume:
        size: '5Gi'
    nonProduction:
      disableClusterPodAntiAffinity: true

EOF
  
  local CREATED_PGBOUNCER=$(kubectl get sgclusters.stackgres.io -n "$CLUSTER_NAMESPACE" "$CLUSTER_NAME-reused" -o=jsonpath={.spec.configurations.sgPoolingConfig})

  if kubectl get sgpoolconfigs.stackgres.io -n $OPERATOR_NAMESPACE $CREATED_PGBOUNCER
  then
    echo "Success. Default pgbouncer was created in the cluster namespace"
  else
    echo "Fail. Default pgbouncer was not created in the cluster namespace"
    return 1;
  fi

  kubectl delete sgclusters -n "$CLUSTER_NAMESPACE" "$CLUSTER_NAME-pgbouncer"

  cat <<EOF | kubectl apply -f -
  apiVersion: stackgres.io/v1beta1
  kind: SGCluster
  metadata:
    name: $CLUSTER_NAME-reused
    namespace: $CLUSTER_NAMESPACE
  spec:
    instances: 1
    postgresVersion: 'latest'
    pods:
      persistentVolume:
        size: '5Gi'
      disableConnectionPooling: false
      disableMetricsExporter: true
      disablePostgresUtil: true        
    nonProduction:
      disableClusterPodAntiAffinity: true
EOF

  if kubectl get sgclusters -n "$CLUSTER_NAMESPACE" "$CLUSTER_NAME-reused"
  then
    echo "Cluster with defaul configuration already created. Succeed"
  else
    echo "Cluster with defaul configuration already created was not created"
    return 1
  fi

  kubectl get sgclusters -n "$CLUSTER_NAMESPACE" "$CLUSTER_NAME-reused"

}

create_empty_cluster_with_no_sidecars() {
  cat <<EOF | kubectl apply -f -
  apiVersion: stackgres.io/v1beta1
  kind: SGCluster
  metadata:
    name: $CLUSTER_NAME-nosidecars
    namespace: $CLUSTER_NAMESPACE
  spec:
    instances: 1
    postgresVersion: 'latest'
    pods:
      persistentVolume:
        size: '512Mi'
      disableConnectionPooling: true
      disableMetricsExporter: true
      disablePostgresUtil: true
    nonProduction:
      disableClusterPodAntiAffinity: true
EOF

  if kubectl get sgclusters -n "$CLUSTER_NAMESPACE" "$CLUSTER_NAME-nosidecars"
  then
    echo "Cluster with no sidecars. Succeed"
  else
    echo "Cluster with no sidecars was not created."
    return 1
  fi

  local DISABLED_CONN_POOL=$(kubectl get sgclusters.stackgres.io -n $CLUSTER_NAMESPACE $CLUSTER_NAME-nosidecars -o json | run_jq -r '.spec.pods.disableConnectionPooling')

  assert_string_equal "true" "$DISABLED_CONN_POOL"

  local DISABLED_METRIC_EXPORTER=$(kubectl get sgclusters.stackgres.io -n $CLUSTER_NAMESPACE $CLUSTER_NAME-nosidecars -o json | run_jq -r '.spec.pods.disableMetricsExporter')

  assert_string_equal "true" "$DISABLED_METRIC_EXPORTER"

  local DISABLED_POSTGRES_UTIL=$(kubectl get sgclusters.stackgres.io -n $CLUSTER_NAMESPACE $CLUSTER_NAME-nosidecars -o json | run_jq -r '.spec.pods.disablePostgresUtil')

  assert_string_equal "true" "$DISABLED_POSTGRES_UTIL"

  kubectl delete sgclusters -n "$CLUSTER_NAMESPACE" "$CLUSTER_NAME-nosidecars"

}

create_empty_cluster() {

  cat <<EOF | kubectl apply -f -
apiVersion: stackgres.io/v1beta1
kind: SGCluster
metadata:
  name: $CLUSTER_NAME
  namespace: $CLUSTER_NAMESPACE
spec:
  instances: 1
  postgresVersion: 'latest'
  pods:
    persistentVolume:
      size: '512Mi'
  nonProduction:
    disableClusterPodAntiAffinity: true
EOF

  local CREATED_PGCONFIG=$(kubectl get sgclusters.stackgres.io -n "$CLUSTER_NAMESPACE" "$CLUSTER_NAME" -o=jsonpath={.spec.configurations.sgPostgresConfig})

  if kubectl get sgpgconfigs.stackgres.io -n $CLUSTER_NAMESPACE $CREATED_PGCONFIG
  then
    echo "Success. Default pgconfig was created in the cluster namespace"
  else
    echo "Fail. Default pgconfig was not created in the cluster namespace"
    return 1;
  fi

  local CREATED_PGCONFIG_FIELDS=$(kubectl get sgpgconfigs.stackgres.io -n $CLUSTER_NAMESPACE $CREATED_PGCONFIG -o json | run_jq '.spec["postgresql.conf"] | length')
  local DEFAULT_PGCONFIG_FIELDS=$(get_default_pgconfig -o json | run_jq '.spec["postgresql.conf"] | length')

  if [ "$CREATED_PGCONFIG_FIELDS" = "$DEFAULT_PGCONFIG_FIELDS" ]
  then
    echo "Success. Defaults pgconfig fields were created"
  else
    echo "Fail. Default pgconfig fields not created"
    return 1
  fi

  local CREATED_PROFILE=$(kubectl get sgclusters.stackgres.io -n "$CLUSTER_NAMESPACE" "$CLUSTER_NAME" -o=jsonpath={.spec.sgInstanceProfile})

  if kubectl get sginstanceprofiles.stackgres.io -n $CLUSTER_NAMESPACE $CREATED_PROFILE
  then
    echo "Success. Default profile was created in the cluster namespace"
  else
    echo "Fail. Default profile was not created in the cluster namespace"
    return 1;
  fi

  local CREATED_PROFILE_FIELDS=$(kubectl get sginstanceprofiles.stackgres.io -n $CLUSTER_NAMESPACE $CREATED_PROFILE -o json | run_jq '.spec | length')
  local DEFAULT_PROFILE_FIELDS=$(get_default_profile -o json | run_jq '.spec | length')

  if [ "$CREATED_PROFILE_FIELDS" = "$DEFAULT_PROFILE_FIELDS" ]
  then
    echo "Success. Defaults profile fields were created"
  else
    echo "Fail. Default profile fields were not created"
    return 1
  fi

  local DEFAULT_ANNOTATION=$(kubectl get sgclusters.stackgres.io -n $CLUSTER_NAMESPACE $CLUSTER_NAME -o json | run_jq '.metadata.annotations["stackgres.io/operatorVersion"]')

  if [ -z "$DEFAULT_ANNOTATION" ] || [ "$DEFAULT_ANNOTATION" = "null" ]
  then
    echo "Fail. Default annotations not created"
    return 1
  else
    echo "Success. Defaults annotations created"    
  fi

  local INSTALLED_CONTAINERS="$(kubectl get pod -n $CLUSTER_NAMESPACE $CLUSTER_NAME-0 -o=jsonpath='{.spec.containers[*].name}')"

  if echo "$INSTALLED_CONTAINERS" | grep "prometheus-postgres-exporter" > /dev/null
  then
    echo "Success. Promethus postgres exporter was installed"
  else
    echo "Fail. Promethus postgres exporter was not installed"
    return 1
  fi

  if echo "$INSTALLED_CONTAINERS" | grep "envoy" > /dev/null
  then
    echo "Success. Envoy was installed"
  else
    echo "Fail. Envoy was not installed"
    return 1
  fi

  assert_string_contains "pgbouncer" "$INSTALLED_CONTAINERS"
  assert_string_contains "postgres-util" "$INSTALLED_CONTAINERS"

  kubectl delete sgclusters -n "$CLUSTER_NAMESPACE" "$CLUSTER_NAME"

}

create_empty_cluster_on_operator_namespace() {
  cat <<EOF | kubectl apply -f -
apiVersion: stackgres.io/v1beta1
kind: SGCluster
metadata:
  name: $CLUSTER_NAME
  namespace: $OPERATOR_NAMESPACE
spec:
  instances: 1
  postgresVersion: 'latest'
  pods:
    persistentVolume:
      size: '512Mi'
    disableConnectionPooling: true
    disableMetricsExporter: true
    disablePostgresUtil: true
  nonProduction:
    disableClusterPodAntiAffinity: true
EOF

  if kubectl get sgclusters.stackgres.io -n $OPERATOR_NAMESPACE $CLUSTER_NAME
  then
    echo "Good. cluster was created on the operator namespace "
    return 0
  else 
    echo "Fail. cluster was not created on the operator namespace "
    return 1
  fi

  kubectl delete sgclusters -n "$OPERATOR_NAMESPACE" "$CLUSTER_NAME"
}