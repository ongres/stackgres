#!/bin/sh

e2e_test_install() {
  if [ "$E2E_ENV" = "kind" ]
  then
    cat << EOF > "$LOG_PATH/minio-affinity.yaml"
minio:
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
          - matchExpressions:
            - key: "kubernetes.io/hostname"
              operator: "In"
              values: [ "${KIND_NAME}-worker", "${KIND_NAME}-control-plane" ]
EOF
  else
    > "$LOG_PATH/minio-affinity.yaml"
  fi

  create_or_replace_cluster "$CLUSTER_NAME" "$CLUSTER_NAMESPACE" 2 \
    -f "$LOG_PATH/minio-affinity.yaml"

  deploy_curl_pod "$CLUSTER_NAMESPACE"

  wait_pods_running "$CLUSTER_NAMESPACE" 4

  OPERATOR_CLUSTER_CR=$(kubectl get sgclusters.stackgres.io -n "$CLUSTER_NAMESPACE" "$CLUSTER_NAME" -o json \
    | jq 'del(.metadata.creationTimestamp) | del(.metadata.generation) | del(.metadata.resourceVersion) | del(.metadata.selfLink) | del(.metadata.uid)' )
  
  write_into -f "$LOG_PATH/stackgres-cluster-cr.json" -c "$OPERATOR_CLUSTER_CR"

  OPERATOR_CLUSTER=$(cat "$LOG_PATH/stackgres-cluster-cr.json" \
    | jq 'del(.apiVersion) | del(.kind)' )

  write_into -f "$LOG_PATH/stackgres-cluster.json" -c "$OPERATOR_CLUSTER" 
  
  kubectl patch sgbackupconfig -n "$CLUSTER_NAMESPACE" backupconf --type json \
    --patch '[{"op":"replace","path":"/spec/baseBackups/cronSchedule","value":"*/1 * * * *"}]'

  wait_until eval '[ "$(kubectl exec -t -n "$CLUSTER_NAMESPACE" "$CLUSTER_NAME"-0 -c patroni -- \
    exec-with-env backup -- wal-g backup-list | wc -l)" -gt 0 ]'
  
}

e2e_test() {
  run_test "Check that a created cluster can be accessed directly through the API" check_cluster_directly

  run_test "Check that a created cluster is included in the response" check_cluster_in_list

  run_test "Check that the status endpoint are returning the master stats" test_cluster_stats_are_loaded

  run_test "Check that the pod config endpoint are returning the pod details" test_cluster_pod_config_are_loaded

  run_test "Check that the number of pods match with the master and replicas" test_cluster_pod_count

  run_test "Check that a cluster was removed after its deletion in the API" check_cluster_removed

  run_test "Check cluster is created with the API and is visible in the API" test_api_created_cluster_is_visible

  run_test "Check cluster is updated with the API are reflected in the API" test_api_updated_cluster_is_visible

  run_test "Check cluster is deleted with the API are reflected in the API" test_api_delete_cluster_is_visible

  run_test "Constraint violations should be detected" test_constraint_violation_api_error

  run_test "User with wrong credentials should not be authenticated" test_authentication_api_error
}

check_cluster_in_list() {
  if run_curl -r "stackgres/sgcluster" \
    | jq -r ".[] | select ( .metadata.namespace == \"$CLUSTER_NAMESPACE\" and .metadata.name == \"$CLUSTER_NAME\") | .metadata.name" \
    | grep -q "^$CLUSTER_NAME$"
  then
    echo "Cluster $CLUSTER_NAME included in json response"
    return 0
  else
    echo "Cluster $CLUSTER_NAME not included in json response"
    return 1
  fi
}

get_cluster_http_status() {
  run_curl -r "stackgres/sgcluster/$CLUSTER_NAMESPACE/$CLUSTER_NAME" -e "-LI -o /dev/null -w %{http_code}"
}

get_cluster_stats() {
  run_curl -r "stackgres/sgcluster/status/$CLUSTER_NAMESPACE/$CLUSTER_NAME" -e "-LI -o /dev/null -w %{http_code}"
}

get_cluster_pod_configs_health() {
  run_curl -r "stackgres/sgcluster/$CLUSTER_NAMESPACE/$CLUSTER_NAME" -e "-LI -o /dev/null -w %{http_code}"
}

get_cluster_pod_count() {
  run_curl -r "stackgres/sgcluster/$CLUSTER_NAMESPACE/$CLUSTER_NAME" | jq '.pods | length'
}

check_cluster_directly() {
  local HTTP_STATUS

  HTTP_STATUS="$(get_cluster_http_status)"

  if [ "$HTTP_STATUS" -eq "200" ]
  then
    echo "Cluster $CLUSTER_NAME was found bye the api"
    return 0
  else
    echo "Cluster $CLUSTER_NAME was not found bye the api"
    return 1
  fi
}

test_cluster_stats_are_loaded() {
  local HTTP_STATUS

  HTTP_STATUS="$(get_cluster_stats)"

  if [ "$HTTP_STATUS" -eq "200" ]
  then
    echo "Cluster $CLUSTER_NAME status was found by the api"
    return 0
  else
    echo "Cluster $CLUSTER_NAME stats was not found by the api"
    return 1
  fi
}

test_cluster_pod_config_are_loaded() {
  local HTTP_STATUS

  HTTP_STATUS="$(get_cluster_pod_configs_health)"

  if [ "$HTTP_STATUS" -eq "200" ]
  then
    echo "Cluster $CLUSTER_NAME pod configs was found by the api"
    return 0
  else
    echo "Cluster $CLUSTER_NAME pod configs was not found by the api"
    return 1
  fi
}

test_cluster_pod_count() {
  local OLD_E2E_TIMEOUT="$E2E_TIMEOUT"

  E2E_TIMEOUT=60

  BACKUP_NAME="${CLUSTER_NAME}-0-$(shuf -i 0-65535 -n 1)"

    cat << EOF | kubectl create -f -
  apiVersion: stackgres.io/v1beta1
  kind: SGBackup
  metadata:
    namespace: "$CLUSTER_NAMESPACE"
    name: "$BACKUP_NAME"
  spec:
    sgCluster: "$CLUSTER_NAME"
    subjectToRetentionPolicy: true
EOF

  if ! wait_until eval '[ "$(get_cluster_pod_count)" -ne 2 ]'
  then
    echo "Good. User initiated backups didn't appear as cluster pods"
  else
    echo "Pods in cluster should be 2. User initiated backups could have being shown as cluster pods"
    return 1
  fi

  E2E_TIMEOUT="$OLD_E2E_TIMEOUT"
}

remove_cluster_cr_if_exists() {
  if kubectl get sgclusters.stackgres.io -n "$CLUSTER_NAMESPACE" "$CLUSTER_NAME"
  then
    kubectl delete sgclusters.stackgres.io -n "$CLUSTER_NAMESPACE" "$CLUSTER_NAME"
    
    wait_until eval '! kubectl get sgclusters.stackgres.io -n "$CLUSTER_NAMESPACE" "$CLUSTER_NAME"'
  fi
}

check_cluster_removed() {
  local HTTP_STATUS

  remove_cluster_cr_if_exists

  if run_curl -r "stackgres/sgcluster" \
    | jq -r ".[] | select ( .metadata.namespace == \"$CLUSTER_NAMESPACE\" and .metadata.name == \"$CLUSTER_NAME\") | .metadata.name" \
    | grep -q "^$CLUSTER_NAME$"
  then
    echo "Cluster $CLUSTER_NAME wasn't removed from cache"
    return 1
  else
    echo "Cluster $CLUSTER_NAME was removed from cache"
    return 0
  fi

  HTTP_STATUS="$(run_curl -r "stackgres/sgcluster/$CLUSTER_NAMESPACE/$CLUSTER_NAME" -e "-LI -o /dev/null -w %{http_code}")"

  if [ "$HTTP_STATUS" -eq "404" ]
  then
    echo "Cluster $CLUSTER_NAME was not found by the api"
    return 0
  else
    echo "Cluster $CLUSTER_NAME was found by the api"
    return 1
  fi
}

create_cluster_with_api() {
  local HTTP_STATUS

  remove_cluster_cr_if_exists

  HTTP_STATUS="$(run_curl -r "stackgres/sgcluster" -d "$LOG_PATH/stackgres-cluster.json" -e '-X POST -w %{http_code} -o /dev/null')"

  if [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "202" ] || [ "$HTTP_STATUS" = "204" ]
  then
    echo "Request acknowledged by the operator"
    return 0
  else
    ERROR_RESPONSE="$(run_curl -r "stackgres/sgcluster" -d "$LOG_PATH/stackgres-cluster.json" -e '-X POST')"
    echo "Invalid response status $HTTP_STATUS. response: $ERROR_RESPONSE"
    return 1
  fi
}

test_api_created_cluster_is_visible() {
  create_cluster_with_api

  if kubectl get sgclusters.stackgres.io -n "$CLUSTER_NAMESPACE" "$CLUSTER_NAME"
  then
    echo "Cluster created with the API"
  else
    echo "Cluster CR was not created"
    return 1
  fi

  check_cluster_directly
}

update_cluster_parameter_with_api() {
  local HTTP_STATUS

  UPDATED_STACKGRES_CLUSTER=$(kubectl get sgclusters.stackgres.io -n "$CLUSTER_NAMESPACE" "$CLUSTER_NAME" -o json \
    | jq 'del(.metadata.creationTimestamp) | del(.metadata.generation) | del(.metadata.resourceVersion) | del(.metadata.selfLink) | del(.metadata.uid)' \
    | jq ".spec[\"$1\"] = $2" )
  
  write_into -f "$LOG_PATH/updated-stackgres-cluster.json" -c "$UPDATED_STACKGRES_CLUSTER"

  HTTP_STATUS="$(run_curl -r "stackgres/sgcluster" -d "$LOG_PATH/updated-stackgres-cluster.json" -e '-X PUT -w %{http_code} -o /dev/null')"

  if [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "202" ] || [ "$HTTP_STATUS" = "204" ]
  then
    echo "Request acknowledged by the operator"
    return 0
  else
    ERROR_RESPONSE="$(run_curl -r "stackgres/sgcluster" -d "$LOG_PATH/updated-stackgres-cluster.json" -e '-X PUT')"
    echo "Invalid response status $HTTP_STATUS. response: $ERROR_RESPONSE"
    return 1
  fi
}

test_api_updated_cluster_is_visible() {
  update_cluster_parameter_with_api 'instances' '2'

  if kubectl get sgclusters.stackgres.io -n "$CLUSTER_NAMESPACE" "$CLUSTER_NAME" -o jsonpath='{.spec.instances}' \
    | grep -q "^2$"
  then
    echo "Cluster instances were increased"
  else
    echo "Cluster instances weren't increase"
    return 1
  fi

  if run_curl -r "stackgres/sgcluster/$CLUSTER_NAMESPACE/$CLUSTER_NAME" | jq '.spec.instances' -r \
    | grep -q "^2$"
  then
    echo "Cluster updates are being reflected in the api"
  else
    echo "Cluster updates aren't being reflected in the api"
    return 1
  fi
}

delete_cluster_with_api() {
  local HTTP_STATUS

  HTTP_STATUS="$(run_curl -r "stackgres/sgcluster" -d "$LOG_PATH/stackgres-cluster.json" -e '-X DELETE -w %{http_code} -o /dev/null')"

  if [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "202" ] || [ "$HTTP_STATUS" = "204" ]
  then
    echo "Request acknowledged by the operator"
    return 0
  else
    ERROR_RESPONSE="$(run_curl -r "stackgres/sgcluster" -d "$LOG_PATH/stackgres-cluster.json" -e '-X PUT')"
    echo "Invalid response status $HTTP_STATUS. response: $ERROR_RESPONSE"
    return 1
  fi
}

test_api_delete_cluster_is_visible() {
  delete_cluster_with_api

  if wait_until eval '[ "$(get_cluster_http_status)" = "404" ]'
  then
    echo "Cluster removed from the API"
  else
    echo "Cluster wasn't removed from the API"
    return 1
  fi
}

test_constraint_violation_api_error() {

  INVALID_PGCONFIG=$(cat "$LOG_PATH/stackgres-cluster.json" | jq '.spec.instances = -1' )

  echo "$INVALID_PGCONFIG" > "$LOG_PATH/invalid-cluster.json"
  
  local HTTP_STATUS

  HTTP_STATUS="$(run_curl -r "stackgres/sgcluster" -n "$CLUSTER_NAMESPACE"  -d "$LOG_PATH/invalid-cluster.json" -e '-X POST -w %{http_code} -o /dev/null')"

  assert_string_equal "422" "$HTTP_STATUS"

  ERROR_RESPONSE="$(run_curl -r "stackgres/sgcluster" -n "$CLUSTER_NAMESPACE" -d "$LOG_PATH/invalid-cluster.json" -e '-X POST')"

  EXPECTED_ERROR_TYPE="constraint-violation"
  EXPECTED_ERROR_TITLE="do not comply with the syntactic rules"
  EXPECTED_ERROR_DETAIL="spec.instances in body should be greater than or equal to 1"
  EXPECTED_ERROR_FIELD="instances"

  assert_api_error "$ERROR_RESPONSE"

}

test_authentication_api_error() {
  local HTTP_STATUS

  HTTP_STATUS="$(run_curl -a e2e:tets -r "stackgres/sgcluster"  -n "$CLUSTER_NAMESPACE" -e "-LI -o /dev/null -w %{http_code}")"

  check_authentication_error

  HTTP_STATUS="$(run_curl -a e2e:tets -r "stackgres/sgcluster/$CLUSTER_NAMESPACE/$CLUSTER_NAME" -n "$CLUSTER_NAMESPACE" -e "-LI -o /dev/null -w %{http_code}")"

  check_authentication_error

  HTTP_STATUS="$(run_curl -a e2e:tets -r "stackgres/sgcluster/status/$CLUSTER_NAMESPACE/$CLUSTER_NAME" -n "$CLUSTER_NAMESPACE" -e "-LI -o /dev/null -w %{http_code}")"

  check_authentication_error

  HTTP_STATUS="$(run_curl -a e2e:tets -r "stackgres/sgcluster/logs/$CLUSTER_NAMESPACE/$CLUSTER_NAME" -n "$CLUSTER_NAMESPACE" -e "-LI -o /dev/null -w %{http_code}")"

  check_authentication_error

  HTTP_STATUS="$(run_curl -a e2e:tets -r "stackgres/sgcluster" -n "$CLUSTER_NAMESPACE" -d "$LOG_PATH/stackgres-cluster.json" -e '-X POST -w %{http_code} -o /dev/null')"

  check_authentication_error

  HTTP_STATUS="$(run_curl -a e2e:tets -r "stackgres/sgcluster" -n "$CLUSTER_NAMESPACE" -d "$LOG_PATH/stackgres-cluster.json" -e '-X PUT -w %{http_code} -o /dev/null')"

  check_authentication_error

  HTTP_STATUS="$(run_curl -a e2e:tets -r "stackgres/sgcluster" -n "$CLUSTER_NAMESPACE" -d "$LOG_PATH/stackgres-cluster.json" -e '-X DELETE -w %{http_code} -o /dev/null')"

  check_authentication_error
}

check_authentication_error() {
  if [ "$HTTP_STATUS" = "401" ]
  then
    echo "Request returned expected authentication error"
    return 0
  else
    echo "Request returned unexpected response status $HTTP_STATUS instead of the expected authentication error."
    return 1
  fi
}